# Извлеченные уроки и ошибки, которых стоит избегать

Этот документ суммирует опыт, полученный при решении комплексной проблемы с фоновыми обработчиками (воркерами) и API Vendista.

### 1. Проблема: `TypeError` в обработчике транзакций

-   **Симптом**: Воркер `vendista_import_worker.js` падал с ошибкой `TypeError: Cannot read properties of undefined (reading '0')`.
-   **Коренная причина**: Асинхронный запрос к базе данных (`pool.query`) вызывался внутри синхронной функции `Array.prototype.filter()`. Код не дожидался ответа от БД и пытался обработать `Promise` вместо реальных данных.
-   **Решение**: Изменить логику. Сначала одним запросом получить все необходимые данные (остатки на складе), сложить их в `Map` для быстрого доступа, и только потом использовать `.filter()` для синхронной обработки данных в памяти.
-   **Урок**: **Никогда не используйте асинхронные операции внутри синхронных методов перебора массивов, таких как `filter`, `map`, `forEach`**, если не используете `Promise.all` для обработки результатов. Это приводит к непредсказуемому поведению и ошибкам.

### 2. Проблема: "Зависшие" пользователи после сбоя оплаты

-   **Симптом**: Пользователи, у которых заканчивалась подписка Vendista, получали статус `payment_required`, и система переставала для них работать, но автоматически не возобновляла работу после оплаты.
-   **Коренная причина**: Отсутствовал механизм, который бы периодически проверял "зависших" пользователей. Система была спроектирована только на отключение, но не на повторное включение.
-   **Решение**: Создание нового воркера (`payment_status_checker_worker.js`), который раз в сутки проверяет таких пользователей, делает тестовый запрос к API и, в случае успеха, автоматически возвращает им статус `active`.
-   **Урок**: При проектировании систем, реагирующих на внешние сбои (как отказ API), всегда продумывайте не только механизм "отключения", но и **механизм автоматического "восстановления"**.

### 3. Проблема: Цепочка ошибок в скрипте ручного запуска (`manual_runner.js`)

-   **Симптом**: Скрипт для ручного запуска задач не работал, выдавая разные ошибки.
-   **Коренные причины (множественные)**:
    1.  **Неверная логика запроса к БД**: Скрипт искал пользователей по слишком строгим критериям (наличие токена), что не подходило для команды `update-creds`.
    2.  **Некорректная обработка `null`**: Код пытался расшифровать `null` токен, что вызывало ошибку.
    3.  **Неверный HTTP-метод**: Для API Vendista использовался `POST` вместо `GET` для получения токена.
    4.  **Неверная проверка ответа**: Код проверял наличие `response.token` вместо `response.success`, что приводило к некорректной интерпретации ответа.
    5.  **Пропущенный импорт**: В одном из файлов отсутствовал импорт функции `encrypt`.
-   **Урок**: Скрипты для ручного управления и отладки **так же важны, как и основной код**. Их нужно тщательно тестировать, особенно разные ветки их логики (разные команды и флаги), так как в критический момент они должны работать безотказно.

### 4. Проблема: Неверная интерпретация ошибок API Vendista

-   **Симптом**: API Vendista возвращало ошибку `404 Not Found` на запрос с неверным токеном. Наша система не была готова к такой интерпретации.
-   **Коренная причина**: Мы ожидали ошибку `401 Unauthorized`.
-   **Решение**: Улучшить обработчик ошибок в `vendista.js`, чтобы он корректно интерпретировал код `404` как "неверный логин или пароль".
-   **Урок**: При работе с внешними API **нельзя полагаться только на документацию или логику**. Нужно изучать их реальное поведение и писать обработчики ошибок, готовые к неожиданным кодам ответа.

---

## 5. Логическая ошибка в `checkAndCreateTasks`

-   **Проблема:** При проверке критических остатков ингредиенты, которые были в рецепте, но **полностью отсутствовали** в таблице остатков (`inventories`), не считались критическими. Система игнорировала самую очевидную проблему — отсутствие товара.
-   **Контекст:** Это приводило к тому, что задачи на пополнение не создавались, хотя ингредиент уже закончился.
-   **Решение:** Мы изменили логику `Array.prototype.filter` в `vendista_import_worker.js`. Теперь, если для ингредиента из рецепта не найдено записи в остатках (`!stock`), он автоматически считается критическим (`return true`).
-   **Урок:** Всегда нужно проверять крайние случаи. "Нет данных" — это тоже важные данные, а не повод для игнорирования.

---

## 6. Засорение корневого `package-lock.json`

-   **Проблема:** В корне проекта появился файл `package-lock.json` с тысячами строк изменений после установки временных зависимостей (`jest`, `dotenv`) для тестового скрипта.
-   **Контекст:** В монорепозитории, где у каждого сервиса (`frontend`, `backend`) есть свой `package.json`, корневая папка должна оставаться чистой от зависимостей, специфичных для одного из сервисов. Выполнение `npm install <пакет>` в корне приводит к созданию "мусорных" `node_modules` и `package-lock.json`.
-   **Решение:**
    1.  Удалить `node_modules` и `package-lock.json` из **корневой** папки.
    2.  Очистить корневой `package.json` от временных зависимостей.
    3.  Проводить тесты, используя инструменты, которые работают в контексте нужного сервиса (например, `manual_runner.js` для бэкенда), чтобы не засорять корень.
-   **Урок:** В монорепозитории всегда следи за тем, в какой директории ты находишься, когда выполняешь `npm install`. Устанавливай зависимости только там, где они действительно нужны.

---

- **Проблема**: При попытке выполнить запланированную задачу (`cron`) возникла ошибка `TypeError: scheduler.runById is not a function`.
- **Анализ**: Ошибка произошла из-за неверного вызова задачи внутри планировщика `node-cron`. Код пытался использовать метод `runById`, который характерен для другой библиотеки (`toad-scheduler`), вместо того чтобы напрямую вызвать нужную асинхронную функцию.
- **Решение**: Заменить `scheduler.runById('taskName')` на прямой вызов `functionName()`.
- **Урок**: При работе с несколькими библиотеками для выполнения схожих задач (например, `node-cron` и `toad-scheduler`), крайне важно четко разделять их API и не смешивать синтаксис вызовов. Всегда проверяйте документацию конкретной библиотеки, которую используете в данном контексте.

---

- **Проблема**: В результате списания ингредиентов `current_stock` в таблице `inventories` мог становиться отрицательным, что не соответствует физической реальности и ломает логику отчетности.
- **Анализ**: Стандартный SQL-запрос `UPDATE inventories SET current_stock = current_stock - ?` не имел защиты от списания большего количества, чем есть в наличии.
- **Решение**: Использовать функцию `GREATEST(0, current_stock - ?)` в SQL-запросе. Это гарантирует, что если результат вычитания будет отрицательным, в поле запишется `0`.
- **Урок**: Всегда защищайте операции, которые изменяют количественные показатели (остатки, баланс), от ухода в отрицательные значения, если это противоречит бизнес-логике. Функции БД, такие как `GREATEST` или `LEAST`, идеально подходят для этого.

---

- **Проблема**: Разные модули и воркеры (`manual_runner.js`, `direct_import.js` и т.д.) имели собственную логику загрузки `.env` файлов, что приводило к конфликтам и трудностям в отладке.
- **Анализ**: Дублирование `require('dotenv').config()` в разных частях приложения может привести к тому, что переменные из одного файла перезаписывают другие, или переменные загружаются не в том порядке.
- **Решение**: Создать единый модуль `backend/utils/envLoader.js`, который отвечает за всю логику определения `NODE_ENV` и загрузки нужного `.env` файла. Все остальные модули должны импортировать его в самом начале своей работы.
- **Урок**: Централизуйте управление конфигурацией и загрузкой переменных окружения. Это делает систему более предсказуемой, упрощает отладку и гарантирует, что все части приложения работают с одинаковым набором настроек.

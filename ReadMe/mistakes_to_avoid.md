# Извлеченные уроки и ошибки, которых стоит избегать

Этот документ суммирует опыт, полученный при решении комплексной проблемы с фоновыми обработчиками (воркерами) и API Vendista.

### 1. Проблема: `TypeError` в обработчике транзакций

-   **Симптом**: Воркер `vendista_import_worker.js` падал с ошибкой `TypeError: Cannot read properties of undefined (reading '0')`.
-   **Коренная причина**: Асинхронный запрос к базе данных (`pool.query`) вызывался внутри синхронной функции `Array.prototype.filter()`. Код не дожидался ответа от БД и пытался обработать `Promise` вместо реальных данных.
-   **Решение**: Изменить логику. Сначала одним запросом получить все необходимые данные (остатки на складе), сложить их в `Map` для быстрого доступа, и только потом использовать `.filter()` для синхронной обработки данных в памяти.
-   **Урок**: **Никогда не используйте асинхронные операции внутри синхронных методов перебора массивов, таких как `filter`, `map`, `forEach`**, если не используете `Promise.all` для обработки результатов. Это приводит к непредсказуемому поведению и ошибкам.

### 2. Проблема: "Зависшие" пользователи после сбоя оплаты

-   **Симптом**: Пользователи, у которых заканчивалась подписка Vendista, получали статус `payment_required`, и система переставала для них работать, но автоматически не возобновляла работу после оплаты.
-   **Коренная причина**: Отсутствовал механизм, который бы периодически проверял "зависших" пользователей. Система была спроектирована только на отключение, но не на повторное включение.
-   **Решение**: Создание нового воркера (`payment_status_checker_worker.js`), который раз в сутки проверяет таких пользователей, делает тестовый запрос к API и, в случае успеха, автоматически возвращает им статус `active`.
-   **Урок**: При проектировании систем, реагирующих на внешние сбои (как отказ API), всегда продумывайте не только механизм "отключения", но и **механизм автоматического "восстановления"**.

### 3. Проблема: Цепочка ошибок в скрипте ручного запуска (`manual_runner.js`)

-   **Симптом**: Скрипт для ручного запуска задач не работал, выдавая разные ошибки.
-   **Коренные причины (множественные)**:
    1.  **Неверная логика запроса к БД**: Скрипт искал пользователей по слишком строгим критериям (наличие токена), что не подходило для команды `update-creds`.
    2.  **Некорректная обработка `null`**: Код пытался расшифровать `null` токен, что вызывало ошибку.
    3.  **Неверный HTTP-метод**: Для API Vendista использовался `POST` вместо `GET` для получения токена.
    4.  **Неверная проверка ответа**: Код проверял наличие `response.token` вместо `response.success`, что приводило к некорректной интерпретации ответа.
    5.  **Пропущенный импорт**: В одном из файлов отсутствовал импорт функции `encrypt`.
-   **Урок**: Скрипты для ручного управления и отладки **так же важны, как и основной код**. Их нужно тщательно тестировать, особенно разные ветки их логики (разные команды и флаги), так как в критический момент они должны работать безотказно.

### 4. Проблема: Неверная интерпретация ошибок API Vendista

-   **Симптом**: API Vendista возвращало ошибку `404 Not Found` на запрос с неверным токеном. Наша система не была готова к такой интерпретации.
-   **Коренная причина**: Мы ожидали ошибку `401 Unauthorized`.
-   **Решение**: Улучшить обработчик ошибок в `vendista.js`, чтобы он корректно интерпретировал код `404` как "неверный логин или пароль".
-   **Урок**: При работе с внешними API **нельзя полагаться только на документацию или логику**. Нужно изучать их реальное поведение и писать обработчики ошибок, готовые к неожиданным кодам ответа.

---

## 5. Логическая ошибка в `checkAndCreateTasks`

-   **Проблема:** При проверке критических остатков ингредиенты, которые были в рецепте, но **полностью отсутствовали** в таблице остатков (`inventories`), не считались критическими. Система игнорировала самую очевидную проблему — отсутствие товара.
-   **Контекст:** Это приводило к тому, что задачи на пополнение не создавались, хотя ингредиент уже закончился.
-   **Решение:** Мы изменили логику `Array.prototype.filter` в `vendista_import_worker.js`. Теперь, если для ингредиента из рецепта не найдено записи в остатках (`!stock`), он автоматически считается критическим (`return true`).
-   **Урок:** Всегда нужно проверять крайние случаи. "Нет данных" — это тоже важные данные, а не повод для игнорирования.

---

## 6. Засорение корневого `package-lock.json`

-   **Проблема:** В корне проекта появился файл `package-lock.json` с тысячами строк изменений после установки временных зависимостей (`jest`, `dotenv`) для тестового скрипта.
-   **Контекст:** В монорепозитории, где у каждого сервиса (`frontend`, `backend`) есть свой `package.json`, корневая папка должна оставаться чистой от зависимостей, специфичных для одного из сервисов. Выполнение `npm install <пакет>` в корне приводит к созданию "мусорных" `node_modules` и `package-lock.json`.
-   **Решение:**
    1.  Удалить `node_modules` и `package-lock.json` из **корневой** папки.
    2.  Очистить корневой `package.json` от временных зависимостей.
    3.  Проводить тесты, используя инструменты, которые работают в контексте нужного сервиса (например, `manual_runner.js` для бэкенда), чтобы не засорять корень.
-   **Урок:** В монорепозитории всегда следи за тем, в какой директории ты находишься, когда выполняешь `npm install`. Устанавливай зависимости только там, где они действительно нужны.

---

- **Проблема**: При попытке выполнить запланированную задачу (`cron`) возникла ошибка `TypeError: scheduler.runById is not a function`.
- **Анализ**: Ошибка произошла из-за неверного вызова задачи внутри планировщика `node-cron`. Код пытался использовать метод `runById`, который характерен для другой библиотеки (`toad-scheduler`), вместо того чтобы напрямую вызвать нужную асинхронную функцию.
- **Решение**: Заменить `scheduler.runById('taskName')` на прямой вызов `functionName()`.
- **Урок**: При работе с несколькими библиотеками для выполнения схожих задач (например, `node-cron` и `toad-scheduler`), крайне важно четко разделять их API и не смешивать синтаксис вызовов. Всегда проверяйте документацию конкретной библиотеки, которую используете в данном контексте.

---

- **Проблема**: В результате списания ингредиентов `current_stock` в таблице `inventories` мог становиться отрицательным, что не соответствует физической реальности и ломает логику отчетности.
- **Анализ**: Стандартный SQL-запрос `UPDATE inventories SET current_stock = current_stock - ?` не имел защиты от списания большего количества, чем есть в наличии.
- **Решение**: Использовать функцию `GREATEST(0, current_stock - ?)` в SQL-запросе. Это гарантирует, что если результат вычитания будет отрицательным, в поле запишется `0`.
- **Урок**: Всегда защищайте операции, которые изменяют количественные показатели (остатки, баланс), от ухода в отрицательные значения, если это противоречит бизнес-логике. Функции БД, такие как `GREATEST` или `LEAST`, идеально подходят для этого.

---

- **Проблема**: Разные модули и воркеры (`manual_runner.js`, `direct_import.js` и т.д.) имели собственную логику загрузки `.env` файлов, что приводило к конфликтам и трудностям в отладке.
- **Анализ**: Дублирование `require('dotenv').config()` в разных частях приложения может привести к тому, что переменные из одного файла перезаписывают другие, или переменные загружаются не в том порядке.
- **Решение**: Создать единый модуль `backend/utils/envLoader.js`, который отвечает за всю логику определения `NODE_ENV` и загрузки нужного `.env` файла. Все остальные модули должны импортировать его в самом начале своей работы.
- **Урок**: Централизуйте управление конфигурацией и загрузкой переменных окружения. Это делает систему более предсказуемой, упрощает отладку и гарантирует, что все части приложения работают с одинаковым набором настроек.

---

## 7. Критичное поле `setup_date` удаляется при обновлении профиля

- **Проблема**: Пользователь обновил настройки профиля (налоги, эквайринг), и после этого у него перестали работать воркеры импорта транзакций. Система просто пропускала его в каждом цикле без каких-либо уведомлений.
- **Симптомы**: 
  - Логи показывали `Skipping user 1 - payment required` (но оплата была в порядке)
  - Ручной импорт возвращал: "Нет пользователей для импорта"
  - В БД `setup_date = NULL`, хотя пользователь точно указывал её при регистрации
- **Коренная причина**: Эндпоинт `POST /api/profile/settings` в `backend/routes/profile.js` имел опасную логику:
  ```javascript
  if (setup_date !== undefined) {
      updateFields.push(`setup_date = $${queryIndex++}`);
      updateValues.push(setup_date === '' ? null : setup_date); // ⚠️ БАГ!
  }
  ```
  Если фронтенд отправлял пустую строку `setup_date: ''` (например, при обновлении других полей), бэкенд интерпретировал это как команду "удалить дату" и записывал `NULL` в БД.
- **Почему это критично**: Поле `setup_date` является **обязательным** для работы всех воркеров импорта. Запрос в `schedule_imports.js` выглядит так:
  ```sql
  SELECT * FROM users WHERE vendista_api_token IS NOT NULL AND setup_date IS NOT NULL
  ```
  Без `setup_date` пользователь полностью исключается из обработки, но система **молча** игнорирует его без каких-либо предупреждений.
- **Решение**:
  1. **Исправлен баг в `profile.js`**: Теперь пропускаем обновление поля, если пришла пустая строка или `null`:
     ```javascript
     if (setup_date !== undefined && setup_date !== null && setup_date !== '') {
         updateFields.push(`setup_date = $${queryIndex++}`);
         updateValues.push(setup_date);
     }
     ```
  2. **Добавлен мониторинг в `schedule_imports.js`**: При каждом запуске воркера система проверяет пользователей с токеном, но без `setup_date`, и отправляет критическое уведомление в админ-бот с инструкциями по восстановлению.
- **Урок**: 
  - **Критичные поля** (без которых не работает основная функциональность) должны иметь дополнительную защиту от случайного удаления.
  - **Молчаливые ошибки** - худшие ошибки. Если система не может обработать пользователя по какой-то причине, она должна **сообщить об этом** администратору.
  - При проектировании API эндпоинтов всегда задавайте вопрос: "Что будет, если фронтенд отправит пустую строку/null/undefined для этого поля?"
  - **Обязательные поля** лучше валидировать на уровне БД с `NOT NULL` + `CHECK` constraints, чтобы предотвратить их удаление даже при ошибках в коде.

---

## 8. Неправильная фильтрация транзакций в аналитике

- **Проблема**: Страница "Аналитика" показывала выручку и количество продаж, отличающиеся от страницы "Финансы" (которая считается источником истины). В "Аналитику" попадали "мусорные" транзакции, а бесплатные напитки не отображались.
- **Анализ**:
  - Страница "Финансы" использовала строгий фильтр: `result = '1'` (успех) AND `reverse_id = 0` (не отменено).
  - Страница "Аналитика" использовала фильтр `amount > 0`. Это приводило к двум проблемам:
    1. Попадали неудачные транзакции (`result != '1'`) с положительной суммой.
    2. Исключались бесплатные напитки (`amount = 0`), которые являются валидными продажами.
- **Решение**:
  1. **Унификация фильтрации**: В `backend/routes/analytics.js` применен тот же фильтр, что и в финансах: `result = '1' AND reverse_id = 0`.
  2. **Обработка NULL**: Добавлена обработка транзакций с `machine_item_id IS NULL` (отображаются как "Unknown Product"), чтобы они не терялись.
  3. **Бесплатные напитки**: Транзакции с `amount = 0` теперь включены в выборку и группируются в отдельную строку "Бесплатные напитки".
- **Урок**:
  - **Единый источник истины**: Логика фильтрации "что считается продажей" должна быть одинаковой во всем приложении (лучше вынести в view или общую функцию).
  - **Нулевые суммы**: В бизнес-логике "продажа" не всегда означает "поступление денег". Бесплатная выдача товара — это тоже продажа (списание склада + факт обслуживания), которая должна учитываться в статистике количества.

# Извлеченные уроки и ошибки, которых стоит избегать

Этот документ суммирует опыт, полученный при решении комплексной проблемы с фоновыми обработчиками (воркерами) и API Vendista.

### 1. Проблема: `TypeError` в обработчике транзакций

-   **Симптом**: Воркер `vendista_import_worker.js` падал с ошибкой `TypeError: Cannot read properties of undefined (reading '0')`.
-   **Коренная причина**: Асинхронный запрос к базе данных (`pool.query`) вызывался внутри синхронной функции `Array.prototype.filter()`. Код не дожидался ответа от БД и пытался обработать `Promise` вместо реальных данных.
-   **Решение**: Изменить логику. Сначала одним запросом получить все необходимые данные (остатки на складе), сложить их в `Map` для быстрого доступа, и только потом использовать `.filter()` для синхронной обработки данных в памяти.
-   **Урок**: **Никогда не используйте асинхронные операции внутри синхронных методов перебора массивов, таких как `filter`, `map`, `forEach`**, если не используете `Promise.all` для обработки результатов. Это приводит к непредсказуемому поведению и ошибкам.

### 2. Проблема: "Зависшие" пользователи после сбоя оплаты

-   **Симптом**: Пользователи, у которых заканчивалась подписка Vendista, получали статус `payment_required`, и система переставала для них работать, но автоматически не возобновляла работу после оплаты.
-   **Коренная причина**: Отсутствовал механизм, который бы периодически проверял "зависших" пользователей. Система была спроектирована только на отключение, но не на повторное включение.
-   **Решение**: Создание нового воркера (`payment_status_checker_worker.js`), который раз в сутки проверяет таких пользователей, делает тестовый запрос к API и, в случае успеха, автоматически возвращает им статус `active`.
-   **Урок**: При проектировании систем, реагирующих на внешние сбои (как отказ API), всегда продумывайте не только механизм "отключения", но и **механизм автоматического "восстановления"**.

### 3. Проблема: Цепочка ошибок в скрипте ручного запуска (`manual_runner.js`)

-   **Симптом**: Скрипт для ручного запуска задач не работал, выдавая разные ошибки.
-   **Коренные причины (множественные)**:
    1.  **Неверная логика запроса к БД**: Скрипт искал пользователей по слишком строгим критериям (наличие токена), что не подходило для команды `update-creds`.
    2.  **Некорректная обработка `null`**: Код пытался расшифровать `null` токен, что вызывало ошибку.
    3.  **Неверный HTTP-метод**: Для API Vendista использовался `POST` вместо `GET` для получения токена.
    4.  **Неверная проверка ответа**: Код проверял наличие `response.token` вместо `response.success`, что приводило к некорректной интерпретации ответа.
    5.  **Пропущенный импорт**: В одном из файлов отсутствовал импорт функции `encrypt`.
-   **Урок**: Скрипты для ручного управления и отладки **так же важны, как и основной код**. Их нужно тщательно тестировать, особенно разные ветки их логики (разные команды и флаги), так как в критический момент они должны работать безотказно.

### 4. Проблема: Неверная интерпретация ошибок API Vendista

-   **Симптом**: API Vendista возвращало ошибку `404 Not Found` на запрос с неверным токеном. Наша система не была готова к такой интерпретации.
-   **Коренная причина**: Мы ожидали ошибку `401 Unauthorized`.
-   **Решение**: Улучшить обработчик ошибок в `vendista.js`, чтобы он корректно интерпретировал код `404` как "неверный логин или пароль".
-   **Урок**: При работе с внешними API **нельзя полагаться только на документацию или логику**. Нужно изучать их реальное поведение и писать обработчики ошибок, готовые к неожиданным кодам ответа.

---

## 5. Логическая ошибка в `checkAndCreateTasks`

-   **Проблема:** При проверке критических остатков ингредиенты, которые были в рецепте, но **полностью отсутствовали** в таблице остатков (`inventories`), не считались критическими. Система игнорировала самую очевидную проблему — отсутствие товара.
-   **Контекст:** Это приводило к тому, что задачи на пополнение не создавались, хотя ингредиент уже закончился.
-   **Решение:** Мы изменили логику `Array.prototype.filter` в `vendista_import_worker.js`. Теперь, если для ингредиента из рецепта не найдено записи в остатках (`!stock`), он автоматически считается критическим (`return true`).
-   **Урок:** Всегда нужно проверять крайние случаи. "Нет данных" — это тоже важные данные, а не повод для игнорирования.

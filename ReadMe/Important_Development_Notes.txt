Important Development Notes

This document provides key considerations and guidelines for development within this project, especially regarding environment-specific configurations and feature implementation.

Development vs. Production Environment (NODE_ENV)

  The project utilizes the NODE_ENV environment variable to differentiate between development and production modes.
  This variable dictates certain behaviors and configurations to ensure that development-specific features do not interfere with the production environment.

  Backend:
    Conditional logic based on NODE_ENV is implemented in various backend files (e.g., app.js, auth.js, middleware/auth.js).
    Development-only features, such as role emulation login via DevEntryPage.js, are active only when NODE_ENV is set to 'development'.
    Ensure that any new development-specific routes or middleware are guarded by NODE_ENV checks.

  Frontend:
    - **DevEntryPage.js & "Выйти (Дев)"**: Для тестирования ролей используется страница входа для разработчика (`DevEntryPage.js`), которая теперь является **основной точкой входа** в приложение в режиме разработки. Также есть специальная кнопка выхода, видимая только в `development` режиме. Это позволяет быстро переключаться между ролями, что является основным способом отладки.
    - **Условный рендеринг**: Компоненты или функции, предназначенные только для разработки, должны рендериться или активироваться на основе `process.env.NODE_ENV`.

Authentication and Authorization

  Access Levels:
    The accessLevel field in the JWT token is critical for authorization.
    Ensure that this field is always correctly populated during token creation (backend/routes/auth.js).
    Middleware (backend/middleware/auth.js) relies on this field to grant or deny access to API endpoints.

  Token Handling:
    The frontend's AuthProvider (App.js) manages the JWT token and user authentication state.
    The isLoading flag within AuthContext is essential for preventing race conditions, ensuring that authenticated API calls are not made before the token is fully loaded and validated.
    When implementing new features that require authentication, always ensure they wait for the authentication state to be ready.

Database and Data Schema

  Local Development Database:
    For local development, pgAdmin 4 or the psql console is preferred for database management [[memory:3339899]].
    Adminer is not used.

  Ingredient Quantities:
    Always store ingredient quantities in base units in all inventories (warehouse and stands) [[memory:2654872]].
    Perform transfers using base values to maintain consistency.

Styling and UI/UX

  Mobile-First Design:
    The project follows a MobileFirst responsive design approach for UI components.
    Modal windows, for example, often template their styles from StockUpModal.css to ensure consistency and responsiveness [[memory:2654889]].

  Service Dashboard Layout:
    The `ServiceDashboardLayout.js` now implements a tab-based navigation for 'service' role users, similar to `MainDashboardLayout`, providing dedicated sections for 'Tasks' and 'Warehouse'.

  Backend Changes and Styles:
    When making backend changes, avoid altering styles and design elements [[memory:3339882]].
    Frontend and backend concerns should remain separated.

Deployment and Versioning

  Deployment Process:
    The workflow involves local development, committing to GitHub, and then deploying by pulling the latest changes on the server [[memory:2986364]].
    The deploy.sh script should not be run automatically by the assistant [[memory:2886951]].

  GitHub Pushes:
    Changes should only be pushed to GitHub when explicitly requested [[memory:2886945]], not automatically after every modification.

General Development Practices

  PowerShell Commands:
    When providing terminal commands, use PowerShell syntax, as the user works on Windows [[memory:2989551]].

  Temporary Logs:
    Remember to remove any temporary console logs (e.g., console.log, debugger statements) before committing changes to avoid cluttering the production environment or exposing sensitive data.

Task Cleanup Worker Testing:
  
  Manual Testing:
    - Воркер можно протестировать вручную, вызвав функцию logTaskCleanup() из backend/worker/task_cleanup_worker.js
    - Для тестирования необходимо загрузить переменные окружения перед импортом воркера
    - Пример: require('dotenv').config({ path: '.env.development' }); const { logTaskCleanup } = require('./worker/task_cleanup_worker');
    
  Verification:
    - Воркер записывает статистику в таблицу worker_logs с job_name = 'task_cleanup'
    - Функция подсчитывает количество задач, которые будут скрыты, и общее количество выполненных задач
    - Планировщик cron можно проверить через cron.getTasks() для подтверждения активности
    - Фильтрация API тестируется через прямые SQL запросы с использованием московского времени
    
  Simulation:
    - Для тестирования "завтрашнего дня" используйте moment().add(1, 'day').startOf('day')
    - Сравнивайте результаты фильтрации "сегодня" и "завтра" для проверки корректности работы

Vendista Payment Status Tracking:

  Purpose:
    - Предотвращает спам уведомлений при неоплаченном аккаунте Vendista
    - Отслеживает статус оплаты каждого пользователя в поле `vendista_payment_status`
    - При ошибке 402 устанавливает статус `payment_required` и отправляет одно уведомление

  Testing:
    - Проверьте статус пользователя: `SELECT vendista_payment_status FROM users WHERE id = <user_id>`
    - Имитация ошибки 402: Временно измените API token в базе данных
    - Проверьте логи воркеров на наличие сообщений о пропуске пользователей
    - Тестируйте ручной сброс статуса: `POST /api/auth/reset-payment-status`

  Manual Reset:
    - SQL: `UPDATE users SET vendista_payment_status = 'active', vendista_payment_notified_at = NULL WHERE id = <user_id>`
    - API: `POST /api/auth/reset-payment-status` с параметром `userId`
    - Проверьте, что после сброса воркеры снова обрабатывают пользователя 
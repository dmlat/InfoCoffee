App ReadMe: Архитектура и ключевые концепции
Этот документ описывает внутреннее устройство системных файлов и основные концепции приложения InfoCoffee.

1. Терминология
Для избежания путаницы в проекте используются следующие синонимы:

Development (дев, разработка): Локальная среда, запускаемая на компьютере разработчика.

Production (прод, релиз): Рабочий сервер, доступный конечным пользователям через Telegram.

2. Конфигурация и запуск
Приложение имеет две среды: development и production, управляемые переменной NODE_ENV.

Точка входа в приложение, backend/app.js, определяет NODE_ENV и загружает соответствующий файл конфигурации. Все остальные модули получают доступ к конфигурации через process.env.

Production (NODE_ENV=production):

Использует backend/.env для всех настроек.

Рассчитан на запуск через менеджер процессов (например, pm2).

Требует наличия всех рабочих токенов, включая TELEGRAM_BOT_TOKEN и ADMIN_TELEGRAM_BOT_TOKEN.

Development (NODE_ENV=development):

Использует ТОЛЬКО backend/.env.development.

Запускается через npm run dev, что поднимает nodemon для бэкенда и react-scripts для фронтенда.

3. Аутентификация и роли
Система аутентификации и управления доступом — одна из самых сложных частей проекта, так как она должна работать и в реальной среде Telegram, и в обычном браузере для разработки.

3.1. Поток аутентификации
Инициация:

- **Prod**: Фронтенд, открытый внутри Telegram, получает от клиента Telegram специальный объект `window.Telegram.WebApp.initData`.

- **Dev**: Для максимального удобства разработки создан специальный интерфейс:
    - **Страница входа (`DevEntryPage.js`)**: Доступна по адресу `http://localhost:3000`. Позволяет разработчику в один клик выбрать роль (`owner`, `admin`, `service`). Это теперь **основная точка входа** в приложение для режима разработки, заменяющая `LoginPage`.
    - **Кнопка "Выйти (Дев)"**: Присутствует на всех страницах в режиме разработки. Позволяет мгновенно сбросить сессию и вернуться на `DevEntryPage` для выбора новой роли. Это основной и рекомендуемый способ тестирования разных уровней доступа.
    - **Механизм эмуляции**: При выборе роли скрипт `frontend/src/utils/dev.js` запрашивает с бэкенда (GET `/api/dev-config`) тестовые ID, генерирует фейковый `initData` и **перезаписывает** объект `window.Telegram` в браузере, обеспечивая корректную смену ролей при каждом клике.

Хендшейк: `initData` (реальный или фейковый) отправляется на эндпоинт `POST /api/auth/telegram-handshake`.

Валидация (`backend/routes/auth.js`):

- В `production` сервер проверяет криптографическую подпись `initData` с помощью `TELEGRAM_BOT_TOKEN`.
- В `development` эта проверка пропускается, а бэкенд доверяет фейковым данным. Эндпоинты `/telegram-handshake` и `/validate-token` синхронизированы и корректно обрабатывают эмулированные роли.

Определение статуса и выдача JWT: Сервер определяет роль пользователя и при успехе возвращает JWT-токен, который используется для всех последующих запросов.

3.2. Управление состоянием на фронтенде
AuthProvider (frontend/src/App.js): Компонент-обертка, который управляет всем циклом аутентификации, хранит состояние authStatus и данные пользователя user.

localStorage (frontend/src/utils/user.js): Утилиты используются для кэширования сессии пользователя в браузере. Компоненты должны получать user через пропсы, а не напрямую из localStorage.

**Критически важный аспект: асинхронность AuthProvider**
Компонент `AuthProvider` работает асинхронно. Он проверяет токен, связывается с бэкендом и только после этого устанавливает состояние пользователя. Компоненты, которые зависят от данных пользователя (например, от его роли `user.accessLevel`), **обязаны** проверять статус загрузки перед тем, как пытаться использовать эти данные.

**Пример правильной защиты:**
```javascript
import { useAuth } from '../App';

const MyComponent = () => {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return <div>Загрузка...</div>; // Показываем заглушку, пока данные не загружены
  }

  // Теперь мы уверены, что user не undefined
  if (user.accessLevel === 'admin') {
    // ... логика для админа
  }
  
  return (
    // ...
  );
};
```
Игнорирование этой проверки приведет к ошибкам `Cannot read properties of undefined`, так как компонент попытается получить доступ к `user.accessLevel` до того, как `user` будет определен.

3.3. Роли и их эмуляция
owner (Владелец): Полный доступ.

admin (Администратор): Полный доступ ко всем функциям, за исключением возможности удаления самого владельца.

service (Обслуживание): Доступ только к странице задач и урезанному функционалу склада для выполнения этих задач. Теперь для этой роли используется отдельный лейаут `ServiceDashboardLayout.js`.

Эмуляция в development-режиме максимально упрощена благодаря странице DevEntryPage.js и кнопке "Выйти (Дев)", что позволяет в один клик переключаться между ролями.

4. Навигация (Routing) - **ОБНОВЛЕНО**
Логика маршрутизации централизована в `frontend/src/App.js` и использует `react-router-dom` v6. Архитектура была полностью переработана для повышения надежности и избежания циклических перенаправлений.

Ключевые принципы:

1.  **Единый родительский маршрут `/dashboard`**: Вместо нескольких конкурирующих роутов теперь существует один основной маршрут, который служит точкой входа для всех авторизованных пользователей.

2.  **Компонент-селектор макета (`DashboardLayoutSelector`)**: Этот компонент находится внутри роута `/dashboard` и его единственная задача — проверить роль аутентифицированного пользователя (`user.accessLevel`) и на основе этой роли отрендерить правильный макет: `MainDashboardLayout` для `owner`/`admin` или `ServiceDashboardLayout` для `service`.

3.  **Компонент для защиты дочерних маршрутов (`ProtectedRoute`)**: Каждый дочерний маршрут, требующий определенных прав (например, страница "Финансы", доступная только админам), обернут в этот компонент. Он проверяет, соответствует ли роль пользователя списку разрешенных ролей. Если нет, пользователь мягко перенаправляется на доступную ему по умолчанию страницу (например, "Задачи" для сервис-инженера).

4.  **Отказ от `DashboardRedirect`**: Компонент-редиректор был полностью удален, так как его логика теперь встроена в саму структуру маршрутов, что делает навигацию более предсказуемой и линейной.

Такая структура полностью исключает возможность возникновения бесконечных циклов переадресации, которые наблюдались ранее, и обеспечивает строгий, но гибкий контроль доступа к разным частям приложения.

5. Ключевые бизнес-процессы
Создание задач: Задачи могут создаваться автоматически (например, по низкому остатку) или вручную. Создавать задачи вручную могут только owner и admin. Ручные задачи помечаются флагом `details: { is_manual: true }`.

Уведомления:

При создании задачи, назначенный исполнитель получает уведомление в Telegram с инлайн-кнопкой для открытия приложения.

Владелец и все админы получают информационное уведомление о том, что задача была поставлена.

Списание остатков:

Происходит автоматически в фоновом режиме (воркером vendista_import_worker.js) после обработки транзакции.

Если по рецепту нужно списать ингредиент, а его остаток уже на нуле, ошибки не происходит. Остаток просто остается на нуле. Уход в минус не допускается благодаря использованию функции GREATEST(0, ...) в SQL-запросах на списание.

Выполнение задачи на пополнение (Restock):

При нажатии кнопки "Выполнить" на задаче типа "restock", пользователь перенаправляется на страницу Склада (Warehouse). При этом интерфейс автоматически выбирает нужный терминал и устанавливает режим "Стойка", что упрощает процесс пополнения и предотвращает случайные ошибки. Эта функциональность работает для всех ролей (owner, admin, service). Логика завершения задачи зависит от её происхождения:
- Если задача создана автоматически (системой), она будет завершена только тогда, когда все ингредиенты, которые были на критическом уровне, будут пополнены выше этого уровня.
- Если задача создана вручную (через интерфейс), она будет завершена, как только будет выполнено любое пополнение (т.е. `quantity_after > quantity_before`) для любых ингредиентов, предназначенных для машины, без необходимости пополнять все критические позиции. Это достигается за счет проверки флага `is_manual` в `details` задачи при обработке перемещения инвентаря в `backend/routes/inventory.js`.

Управление задачами:

Выполненные задачи остаются в базе данных для будущей аналитики и не удаляются автоматически. Владелец и администраторы могут вручную удалить задачи из журнала через интерфейс, если это необходимо.

Автоматическое скрытие выполненных задач:
Выполненные задачи автоматически скрываются из журнала задач в конце календарного дня по московскому времени. Задачи остаются в базе данных для аналитики, но не отображаются в интерфейсе. 

Воркер task_cleanup_worker.js:
- Запускается каждый день в 23:59 по московскому времени
- Подсчитывает количество задач, которые будут скрыты
- Записывает статистику в таблицу worker_logs
- Логирует результат в консоль приложения
- Отправляет уведомления об ошибках администраторам

Механизм фильтрации:
- GET /api/tasks автоматически фильтрует задачи при каждом запросе
- Показывает только pending задачи и completed задачи, завершенные с начала текущего дня
- Использует московское время для определения начала дня
- Фильтрация происходит на уровне SQL запроса для оптимальной производительности

6. Ключевые файлы